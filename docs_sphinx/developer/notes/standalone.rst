Standalone Brian planning (15 May 2013)
=======================================

This document is designed to summarise the work that has been done so far on the
standalone/devices part of Brian 2, and outline the issues and options for
the final implementation.

For an earlier document, see :doc:`../codegen/compiler`.

As a reminder, the general idea of Brian standalone is to generate code that
is entirely independent of Brian that runs a specific simulation.

Design aims
-----------

* As little work for the user as possible, ideally they should just have to
  add one line to specify that their code should not be run but generate
  standalone code instead. The rationale for this is directly one of Brian's
  overall aims of making the simulation process as easy as possible.
  
* Should cover as much as possible of Brian's functionality. The rationale here
  is again straightforward: it's more useful the more of Brian's functionality
  it covers. Also, if it doesn't cover enough functionality people will just
  dismiss the tool as useless generally, even if it might cover some use cases.
  
* Should require the minimum amount of work possible to implement a new
  language or device. Should require the minimum amount of maintenance work to
  update a language when Brian features change. Should be as simple as possible
  to write a new language or device. There are various rationales
  for this: we are a small team and have a limited amount of time to develop;
  we want to encourage other people to write new languages/devices for Brian,
  and so it has to be easy and not too much work; we do not want the main
  Brian code to go out of sync with the standalone code. This last point
  is critical, the more work you have to do in duplicating functionality
  the more likely it is that it will not work correctly and/or will drift
  out of sync with the rest of Brian.
  
* The standalone code should never silently go wrong, it should always
  explicitly raise an error if a feature is not fully implemented. Again,
  the rationale is standard Brian 2 design.

* The generated code should be readable and modifiable. The rationale for this
  is that it is probably going to be rare that the user just generates code
  and runs it unproblematically. More likely, their code will require something
  we cannot handle statically (e.g. loops, functions, etc.), or they will
  want to embed the code produced by Brian into a more complex program (i.e.
  they will use Brian to do 90% of the work in implementing their full
  simulation). If we want standalone code generation to be useful, we have to
  acknowledge the fact that we won't be able to do 100% of what the user wants
  ourselves, and make it easy to work on the code generated by Brian after it
  has been generated.
  
It will not be possible to 100% fulfil all of these aims.

Issues
------

Setting values
~~~~~~~~~~~~~~

The user may well want to write something like this::

  G.v = rand(len(G))
  
In Brian this is perfectly standard, but it causes a big problem for standalone
code generation. As far as Brian can see, without analysing the source code of
the user script, it sees essentially ``setattr(G, 'v', x)`` where ``x`` is
just an array of values which it has no idea how they were created. We can
translate this into standalone code by computing ``rand(len(G))`` and saving
the value to a file, then loading it in the standalone code, but this is
probably not going to match the intention of the user (which is to have it
randomised each time the code is run).

There is a solution, which is to encourage or force the user to write::

  G.v = 'rand()'

Doing this unfortunately violates the aim of having the user only have to
write one line of code to change from runtime to standalone mode. However,
it may be necessary in order to fulfil the aim of having the code never
silently do the wrong or unexpected thing for the user.

Namespaces
~~~~~~~~~~

A big (and for the moment unsolved) issue is how we deal with changing
namespaces. One of the key elements of the current Brian 2 design is that
each time `Network.run` is called, it recreates the state updater, threshold,
reset code using the current values in the `NeuronGroup` namespace. This is
fine for runtime Brian, but for the standalone version it is problematic
because we cannot do the same thing (we will not port the equation handling
and code generation stuff to the standalone versions).

One option here is to restrict users, when using the standalone mode, to
(a) only changing values in namespaces,
not changing things that require generation of new code, (b) using only
explicit namespaces, and not using the global namespace.

Loops
~~~~~

One of the things users may want to do is write::

  for tau in tau_values:
    G.tau = tau
    run(duration)
    
These is problematic because without analysing the Python source code directly,
we will not know there is a loop there. We can get around this by doing
something like::

  for tau in forloop('tau', tau_values):
    G.tau = tau
    run(duration)
    
The ``forloop`` function would allow the user to give a hint to us what their
intention is, and allow us to generate appropriate code.

Alternatively, we can just not worry about it and then the outputted code will
be an unrolled loop, equivalent to::

  G.tau = tau_values[0]
  run(duration)
  G.tau = tau_values[1]
  run(duration)
  ...
  
Functions
~~~~~~~~~

The user may want to write a function that does something, e.g.::

  def getrate(param):
    ... (set up a network based on param)
    run(duration)
    return mon.nspikes/duration

The problem here is similar to that in the case of loops, but even more
difficult to solve. We could potentially solve this with a decorator::

  @brianfunction
  def getrate(param):
    ...
  
Approaches
----------

Static versus dynamic construction
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

So far we have two major approaches to the construction of objects.

*Static construction*

  We construct the object entirely in Python code, write it to a file, and then
  load this file in the standalone code. The benefit of this is that it
  means we have to do minimal work in writing the standalone code, and we
  get all of the flexibility of the main part of Brian. The bad side is that we
  cannot do some things (random number initialisation), and the code will be
  much less readable and modifiable. In addition, sometimes the files will
  be enormous (e.g. gigabytes for synapses).
  
*Dynamic construction*

  We construct the object entirely on the device. When the user writes Python
  code like::
  
    G.v = 1
    
  We convert this to code on the device that does the same thing. The good side
  of this is that it allows for construction of objects without saving
  enormous data files, it can handle random initialisation. The bad side is
  that it puts limit on the user (they cannot write ``G.v = rand(len(G))``)
  and requires a lot more work.
  
I (Dan) would suggest we only do dynamic construction, because it seems to me
that static construction is too limiting to be really useful. However, there
are various options in between, for example having dynamic construction as
the default option, but allowing an override for static construction in case
the dynamic construction is missing some features that the user wants.

Current approach
~~~~~~~~~~~~~~~~

The current approach that I (Dan) have implemented works as follows. The user
writes code like the following::

  from brian import *
  from brian.devices.cpp import *
  ... (construct network)
  run(duration)
  build()
  
Until the ``build()`` function is called, nothing happens. Internally, this
works as follows. The second import replaces, e.g. ``NeuronGroup`` with a new
class (derived from the original ``NeuronGroup``) that stores a copy of each
method call of the created object. When ``build()`` is called it goes through
this saved list of method calls and attempts to translate them into
standalone code.

There are two sections of C++ code written. The first is called ``brianlib``
and consists of statically writted code that is simply copied to the user
directory. The idea is that as much as possible should go in here, and to some
extent this statically written code is just a reimplementation of Brian in
C++ (minus the code generation, parameter checking, etc.). Here is an example
of a method implementation for the C++ version of Brian::

	void NeuronGroup::set_state(string name, scalar value)
	{
		scalar *arr = arrays[name];
		for(int i=0; i<_num_neurons; i++)
			arr[i] = value;
	}

The second section of code is template files. These are dynamically generated
for each Brian object. So for example, for a `NeuronGroup` with name ``grp``
we would dynamically generate a class ``C_grp`` derived from ``NeuronGroup``
with some additional methods, etc.
For example here is a section of the `NeuronGroup` C++ template file::

	void CLASSNAME::thresholder()
	{
		spikes.clear();
		spikes.reserve(_num_neurons);
		{{thresholder_code.hashdefines}}
		{{thresholder_code.pointers}}
	    for(int _neuron_idx=0; _neuron_idx<_num_neurons; _neuron_idx++)
	    {
	    	{{thresholder_code.code}}
	    	if(_cond) {
	    		spikes.push_back(_neuron_idx);
	    		if(recordspikes)
	    			spikefile << _neuron_idx << " " << clock.t() << endl;
	    	}
	    }
	}

The text that looks like ``{{...}}`` is template code in the Jinja template
format (which is very nice).

This approach is currently implemented, and can reproduce the IF-curve example
giving identical results to the original.

Other approaches
~~~~~~~~~~~~~~~~

We currently have four possible approaches to use which we need to decide
between (or find something better). My (Dan) current favourite is the final
suggestion which is somewhat of a synthesis of the others. In all of these
approaches, the templating side works in essentially the same way with a
static ``brianlib`` and separate templates in Jinja format, since that part
at least is uncontroversial. The differences relate to the Python code, and
the way in which the standalone code is integrated with the rest of the Brian
code.

*Dynamic trickery*

	This is the current approach described above. The standalone code is
	written entirely separately from the main Brian code, and uses dynamic
	Python tricks (like replacing method calls at run time) to store lists of
	method calls. The benefits of this method are that the two parts are
	coded separately, and you don't need to duplicate any code for the main
	part of Brian. The negatives are that it is a bit unstable because the
	standalone code generation stuff is essentially working against the main
	code, allowing it do some things but stopping it from doing other things.
	
*Rewrite and refactor*

	This was the original plan. The idea is that to implement a device we
	rewrite all of the key Brian objects from scratch. This ideally isn't as
	much work as it sounds because they don't actually have to do any
	computational work, and you refactor as much as possible into separate
	modules (e.g. all the equations stuff is in the equations module). The
	good side is that you have no interdependencies between the runtime and
	standalone code. The bad side is you have a lot of code duplication.
	
*Universal base classes*

	We separate out the code for each Brian object into two parts, a
	'universal' base class which does work that is common to both runtime
	and standalone, and then we derive a class from this that does things like
	allocate memory and do computations (for runtime mode) or generate code
	(for standalone mode). The idea would be to do as much as possible in the
	universal base class (e.g. ``UniversalNeuronGroup``), so as to minimise the
	amount of duplication. The benefit of this approach is that it minimises
	duplication, it's quite logically coherent, it separates the definition of
	each object from its implementation. The bad side is that it adds more
	work in the short term because a lot of existing code would have to be
	refactored into different classes.
	
*Computational engine separate*

	The idea here is very much like for universal base classes, except that
	now we only have one class rather than three for user visible classes,
	and this class does not do any computational work itself, instead it 
	creates objects which do this work. So for example, there would be a
	single `NeuronGroup` class, and the code for `NeuronGroup` itself would
	only handle the manipulation of equations, etc. There would be separate
	objects that in the case of runtime code would handle allocating memory,
	running state updaters, thresholds, etc., and in the case of standalone
	would generate code to do these functions. Essentially this works like
	universal base classes except that rather than derive classes and then
	add functionality to derived classes, you have a separate object that 
	adds that functionality. Benefits of this are similar to universal base
	classes with the additional benefit that it simplifies the class
	hierarchy, and makes the separation between definition and implementation
	even sharper (which is probably better). In addition, it may be possible
	that even more could go in ``brianlib`` and less in templated code.
	
	Another side benefit of the computational engine separate approach is that
	you could have not only a standalone and runtime mode, but actually
	multiple different runtime modes. For example, it would leave open the
	option to use GPU in runtime as well as standalone mode.
	
	
So, as is clear, my favourite is the last option. I really like that it keeps
the implementation and definition parts separate, and keeps our options open
for multiple runtime modes. In terms of work, it means a relatively large
restructuring of existing code, but not as much as you might think. It also
imposes a standard way of doing things for future code, namely everyone
writing core Brian code has to make sure to keep the parts that do computational
work separate and put them into separate objects and classes. I think that's
OK though, good in fact.